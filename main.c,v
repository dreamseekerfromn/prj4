head	1.64;
access;
symbols;
locks
	o2-yi:1.64; strict;
comment	@ * @;


1.64
date	2016.11.07.12.58.27;	author o2-yi;	state Exp;
branches;
next	1.63;

1.63
date	2016.11.07.12.21.38;	author o2-yi;	state Exp;
branches;
next	1.62;

1.62
date	2016.11.07.01.12.37;	author o2-yi;	state Exp;
branches;
next	1.61;

1.61
date	2016.11.07.00.39.28;	author o2-yi;	state Exp;
branches;
next	1.60;

1.60
date	2016.11.06.16.12.08;	author o2-yi;	state Exp;
branches;
next	1.59;

1.59
date	2016.11.06.14.43.50;	author o2-yi;	state Exp;
branches;
next	1.58;

1.58
date	2016.11.06.03.31.47;	author o2-yi;	state Exp;
branches;
next	1.57;

1.57
date	2016.11.05.20.48.48;	author o2-yi;	state Exp;
branches;
next	1.56;

1.56
date	2016.11.03.09.32.49;	author o2-yi;	state Exp;
branches;
next	1.55;

1.55
date	2016.10.25.03.15.46;	author o2-yi;	state Exp;
branches;
next	1.54;

1.54
date	2016.10.25.02.59.43;	author o2-yi;	state Exp;
branches;
next	1.53;

1.53
date	2016.10.24.22.04.46;	author o2-yi;	state Exp;
branches;
next	1.52;

1.52
date	2016.10.24.21.54.00;	author o2-yi;	state Exp;
branches;
next	1.51;

1.51
date	2016.10.24.10.10.19;	author o2-yi;	state Exp;
branches;
next	1.50;

1.50
date	2016.10.22.09.30.02;	author o2-yi;	state Exp;
branches;
next	1.49;

1.49
date	2016.10.20.04.21.08;	author o2-yi;	state Exp;
branches;
next	1.48;

1.48
date	2016.10.19.23.08.06;	author o2-yi;	state Exp;
branches;
next	1.47;

1.47
date	2016.10.19.22.09.58;	author o2-yi;	state Exp;
branches;
next	1.46;

1.46
date	2016.10.10.22.32.31;	author o2-yi;	state Exp;
branches;
next	1.45;

1.45
date	2016.10.09.00.17.05;	author o2-yi;	state Exp;
branches;
next	1.44;

1.44
date	2016.10.09.00.10.45;	author o2-yi;	state Exp;
branches;
next	1.43;

1.43
date	2016.10.08.09.24.54;	author o2-yi;	state Exp;
branches;
next	1.42;

1.42
date	2016.10.08.09.17.16;	author o2-yi;	state Exp;
branches;
next	1.41;

1.41
date	2016.10.08.08.04.26;	author o2-yi;	state Exp;
branches;
next	1.40;

1.40
date	2016.10.08.07.24.19;	author o2-yi;	state Exp;
branches;
next	1.39;

1.39
date	2016.10.08.07.22.36;	author o2-yi;	state Exp;
branches;
next	1.38;

1.38
date	2016.10.08.00.33.48;	author o2-yi;	state Exp;
branches;
next	1.37;

1.37
date	2016.10.06.09.13.24;	author o2-yi;	state Exp;
branches;
next	1.36;

1.36
date	2016.10.06.09.11.41;	author o2-yi;	state Exp;
branches;
next	1.35;

1.35
date	2016.10.06.07.47.21;	author o2-yi;	state Exp;
branches;
next	1.34;

1.34
date	2016.10.05.05.19.38;	author o2-yi;	state Exp;
branches;
next	1.33;

1.33
date	2016.10.05.04.52.09;	author o2-yi;	state Exp;
branches;
next	1.32;

1.32
date	2016.10.05.02.48.36;	author o2-yi;	state Exp;
branches;
next	1.31;

1.31
date	2016.10.05.02.46.06;	author o2-yi;	state Exp;
branches;
next	1.30;

1.30
date	2016.10.04.13.00.35;	author o2-yi;	state Exp;
branches;
next	1.29;

1.29
date	2016.10.03.22.15.55;	author o2-yi;	state Exp;
branches;
next	1.28;

1.28
date	2016.10.03.21.58.19;	author o2-yi;	state Exp;
branches;
next	1.27;

1.27
date	2016.10.03.21.54.04;	author o2-yi;	state Exp;
branches;
next	1.26;

1.26
date	2016.10.03.05.37.24;	author o2-yi;	state Exp;
branches;
next	1.25;

1.25
date	2016.10.03.04.12.12;	author o2-yi;	state Exp;
branches;
next	1.24;

1.24
date	2016.10.02.21.53.02;	author o2-yi;	state Exp;
branches;
next	1.23;

1.23
date	2016.10.02.08.43.59;	author o2-yi;	state Exp;
branches;
next	1.22;

1.22
date	2016.10.02.04.28.08;	author o2-yi;	state Exp;
branches;
next	1.21;

1.21
date	2016.10.02.04.19.05;	author o2-yi;	state Exp;
branches;
next	1.20;

1.20
date	2016.09.30.22.44.12;	author o2-yi;	state Exp;
branches;
next	1.19;

1.19
date	2016.09.27.07.58.56;	author o2-yi;	state Exp;
branches;
next	1.18;

1.18
date	2016.09.17.14.18.50;	author o2-yi;	state Exp;
branches;
next	1.17;

1.17
date	2016.09.16.12.20.35;	author o2-yi;	state Exp;
branches;
next	1.16;

1.16
date	2016.09.16.12.04.32;	author o2-yi;	state Exp;
branches;
next	1.15;

1.15
date	2016.09.16.12.03.46;	author o2-yi;	state Exp;
branches;
next	1.14;

1.14
date	2016.09.16.12.02.44;	author o2-yi;	state Exp;
branches;
next	1.13;

1.13
date	2016.09.14.21.49.20;	author o2-yi;	state Exp;
branches;
next	1.12;

1.12
date	2016.09.14.18.35.38;	author o2-yi;	state Exp;
branches;
next	1.11;

1.11
date	2016.09.14.18.01.02;	author o2-yi;	state Exp;
branches;
next	1.10;

1.10
date	2016.09.14.17.59.08;	author o2-yi;	state Exp;
branches;
next	1.9;

1.9
date	2016.09.14.16.08.00;	author o2-yi;	state Exp;
branches;
next	1.8;

1.8
date	2016.09.14.16.03.25;	author o2-yi;	state Exp;
branches;
next	1.7;

1.7
date	2016.09.14.15.46.15;	author o2-yi;	state Exp;
branches;
next	1.6;

1.6
date	2016.09.14.15.34.24;	author o2-yi;	state Exp;
branches;
next	1.5;

1.5
date	2016.02.11.00.40.33;	author o3-yi;	state Exp;
branches;
next	1.4;

1.4
date	2016.02.10.18.03.50;	author o3-yi;	state Exp;
branches;
next	1.3;

1.3
date	2016.02.10.17.55.01;	author o3-yi;	state Exp;
branches;
next	1.2;

1.2
date	2016.02.10.15.44.32;	author o3-yi;	state Exp;
branches;
next	1.1;

1.1
date	2016.02.10.13.43.26;	author o3-yi;	state Exp;
branches;
next	;


desc
@init
@


1.64
log
@*** empty log message ***
@
text
@#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <time.h>
#include "log.h"
#include "pcb.h"


//global var
int shmid;
int turn_id;
int semid;
char *fname = "test.out";
pcb *p;

//prototype for signal handler
void sig_handler(int signo);
void kill_shm();
void kill_sem();
void semlock();
void semunlock();

//proto for queue
void init_queue(void);
void clear_queue(void);
int put(int);
int get(void);
int isEmpty(void);
int isFull(void);

int 
main(int argc, char *argv[]){
	//init var
	int c, hflag, sflag, lflag, iflag, tflag;
	
	//char *fname = "test.out";	//for -l switch, default is logfile.txt
	int option_index = 0;		//for getopt_long
	int err_flag = 0;		//for getopt_long
	char *strbuff = "3";		//handling default value for -n

	char *endptr;			//for strtol
	long value;			//for strtol

	int pid = getpid();		//for pid
	int sig_num;			//for signal
	int temp_pid;

	int tmp_timer;			//tmp store for time quantum
	int current_process;		//tmp storage for the position index

	int i;				//process nth number
	long process_num = 5;		//number of process
	char *max_writes = "3";		//maximum number of writing
	long timer = 20;		//time to terminate
	char text[20];
	int pcb_index;			//index to store new pid in pcb
	char str[256];			
	int stock = 0;			//number of stock for forking, will increase every sec
	struct timespec tps;

	//int shmid;
	//pcb *p;
	osc *o;

	signal(SIGINT, sig_handler);	//handling signal

	opterr = 0;

	//initialize flags
	hflag = 0;
	sflag = 0;
	lflag = 0;
	iflag = 0;
	tflag = 0;

	//declare long options
	struct option options[] = {
		{"help", 0, 0, 'h'},
		{0,0,0,0}
	};

	//getopt_long will be used to accept long switch
	//short ones will be h,n,l
	if (argc >1){
		while(( c = getopt_long(argc,argv, ":hs:l:i:t:", options,&option_index)) != -1)
			switch (c)
				{
					//-h, --help for information about switch
					case 'h':
						hflag = 1;
						break;
					//-n to print different integer on the logfile
					case 's':
						sflag = 1;

						//strtol to check int or not
						value = strtol(optarg,&endptr, 10);
						if(*endptr !='\0')
							{
								printf("oss : you must type digits after -s, not %s",stderr);
								return 1;
							}
						process_num = value;
						if(process_num > MAXP)
							{
								fprintf(stderr,"oss : cannot spawn more than %s processes\n",MAXP);
								return 1;
							}
						break;
					//-l to change logfile name
					case 'l':
						lflag = 1;
						if(strncmp(optarg,"-",1) == 0)
							{
								perror("oss : you must type file name after -l switch.");
								return 1;
							}
						fname = (char*) malloc(strlen(optarg)+1);
						strcpy(fname,optarg);
						break;
					//-t for timer
					case 't':
						tflag = 1;
						value = strtol(optarg,&endptr,10);
						if(*endptr != '\0')
							{
								printf("oss : you must type digits after -t, not %s",stderr);
								return 1;
							}
						timer = value;
						break;
					//errors in getopt
					case '?':
						err_flag = 1;
						printf("Unknown option : -%c is found\n", optopt);
						break;
				}
	}
	//if errflag is on, just exit
	if (err_flag ==1)
		{
			return 1;
		}

	//if iflag is on
	//print simple definition and then term
	if (hflag == 1)
		{
			printf("this program is designed for testing log library function\n");
			printf("-h --help\n print options\n");
			printf("-s [value]\n to spawn [value] of slave processes\n");
			printf("-l [filename]\n change logfile name to [filename]\n");
			printf("-t [value]\n change the termination timer for oss process to [value] second\n");
			return 0;
		}

	//shmget to create shared memories
	//first one for counting
	//second for the algorithm
        if ((shmid = shmget((key_t)12348888, sizeof(osc), 0600|IPC_CREAT)) == -1)
                {
                        perror("oss : fail to create a shared memory\n");
                        create_log("oss : fail to create a shared memory\n");
                        savelog(fname);
                        return 1;
                }
        else
                {
                        create_log("oss : created a shared memory");
                        savelog(fname);
                        clearlog();
                }

        if ((turn_id = shmget((key_t)88881234, sizeof(pcb)*20, 0600|IPC_CREAT)) == -1)
                {
                        perror("oss : fail to create a shared memory for the peterson algorithm\n");
                        create_log("oss : fail to create a shared memory for the peterson algorithm\n");
                        savelog(fname);
                        return 1;
                }
        else
                {
                        create_log("oss : created a second shared memory");
                        savelog(fname);
                        clearlog();
                }

	//attatching shared memories
        if ((o = (osc *)shmat (shmid, NULL, 0)) == -1)
                {
                        perror("oss : fail to attatch the shared memory\n");
                        create_log("oss : fail to attatch the shared memory");
                        savelog(fname);
                        return 1;
                }
        else
                {
                        create_log("oss : success to attatch the shared memory");
                        savelog(fname);
			clearlog();
                }

        if ((p = (pcb *)shmat(turn_id,NULL,0)) == -1)
                {
                        perror("oss : fail to attatch the second shared memory\n");
                        create_log("oss : fail to attatch the second shared memory");
                        savelog(fname);
                        return 1;
                }
        else
                {
                        create_log("oss : success to attatch the second shared memory");
                        savelog(fname);
			clearlog();
                }

	//semaphore
	if((semid = semget((key_t)11114444,1,0600|IPC_CREAT)) == -1)
		{
			perror("oss : fail to create seamphore\n");
			create_log("oss : fail to create semaphore");
			savelog(fname);
			clearlog();
			exit(1);
		}
	else
		{
			create_log("oss : created semaphore");
			savelog(fname);
			clearlog();
		}

	//init pcb
	int k;
	for (k = 0; k<MAXP; k++)
		{
			p->pid[k] = -1;
			p->flag[k] = 0;
		}

	//assign oss process to 0th slot
	p->pid[0] = pid;
	p->num_proc = process_num;
	p->r_process = MAXP-1;
	p->quantum = 50;
	p->term_proc = 0;
	init_queue();
	i = 0;
	
	//init clock
	o->sec = 0;
	o->nsec = 0;

	//init start time in real system clock
	clock_gettime(CLOCK_REALTIME, &tps);

	//forking
	for(k = 1; k<process_num+1; k++)
		{
			pcb_index = k;		//assing k value to pcb_index ;will be used later

			//log
			fflush(stdout);
			create_log("oss : forking a child process");
			savelog(fname);
			clearlog();
			
			//forking
			temp_pid = fork();
			
			//fork result
			if (temp_pid == -1)
				{
					perror("oss : fail to fork a child process\n");
					create_log("oss : fail to fork a child process");
					perror("oss : move to terminating sequence\n");
					create_log("oss : move to terminating sequence\n");
					savelog(fname);
					clearlog();
					
					//kill shm & sem
					kill_shm();
					kill_sem();
					
					perror("oss : oss is terminated due to fail for forking processes\n");
					create_log("oss : oss is terminated due to fail for forking processes");
					savelog(fname);
					return 1;
				}
			else if(temp_pid == 0)
				{
					if (lflag == 1)
						{
							snprintf(text,sizeof(text), "%d", k);
							//
							if((execl("./slave", "slave",text, "-i", max_writes, "-l", fname, NULL)) == -1)
								{
									perror("slave : fail to exec the process image\n");
									create_log("slave : fail to exec the process image");
									perror("process : move to terminating sequence\n");
									create_log("process : move to terminating sequence");
									savelog(fname);
									clearlog();
									
									kill_shm();
									kill_sem();
									
									perror("process : process is terminated due to fail to exec its process image\n");
									create_log("process : process is terminated due to fail for exec its process image");
									savelog(fname);
									return 1;
								}
						}
					else
						{
							snprintf(text,sizeof(text), "%d", k);
							//place for child
							//exec
							if((execl("./slave", "slave",text , "-i", max_writes,"-l",fname, NULL)) == -1)
								{
									//getting error 
									perror("slave : fail to exec the process image\n");
									create_log(" slave: fail to exec the process image");
									perror("process : move to terminating sequence\n");
									create_log("process : move to terminating sequence");
									savelog(fname);
									clearlog();

									kill_shm();
									kill_sem();

									perror("process : process is terminated due to fail to exec its process image\n");
									create_log("process : process is terminated due to fail for exec its process image");
                                                                        savelog(fname);

									return 1;
								}
						}
				}
			else
				{
					//parent process' work
					p->pid[k] = temp_pid;
					p->priority[k] = 1;
					p->flag[k] = NEW;
					p->wait_t[k] = 0;
					p->turnaround_t[k] = 0;
					p->last_burst[k] = 0;
					p->r_process--;
				}
		}
	sleep(1);
	//start the timer
	do
		{
			if((stock > 0)&&(p->r_process>0))
				{
					p->num_proc++;
					pcb_index++;
					temp_pid = fork();
					fflush(stdout);
					create_log("oss : forking a child process");
					savelog(fname);
					clearlog();

					if (temp_pid == -1)
						{
                		                        perror("oss : fail to fork a child process\n");
 		                                        create_log("oss : fail to fork a child process");
							perror("oss : move to terminating sequence\n");
							create_log("oss : move to terminating sequence\n");
							savelog(fname);
							clearlog();
							kill_shm();
							kill_sem();
							perror("oss : oss is terminated due to fail for forking processes\n");
							create_log("oss : oss is terminated due to fail for forking processes");

                                        		return 1;
						}
 		                       else if(temp_pid == 0)
                                		{
							if (lflag == 1)
                                                		{
 		                                                       snprintf(text,sizeof(text), "%d", pcb_index);
                                                        
				                                         if((execl("./slave", "slave",text, "-i", max_writes, "-l", fname, NULL)) == -1)
        		                                                        {
                        		                                                perror("slave : fail to exec the process image\n");
                                        		                                create_log("slave : fail to exec the process image");
											perror("process : move to terminating sequence\n");
											create_log("process : move to terminating sequence");

                                                       			                savelog(fname);
											clearlog();
											kill_shm();
											kill_sem();
											perror("process : process is terminated due to fail to exec its process image\n");
											create_log("process : process is terminated due to fail for exec its process image");
											return 1;
                                                                		}
 		                                               }
                		                        else
                               			                 {
 		                                                       snprintf(text,sizeof(text), "%d", pcb_index);

                		                                        if((execl("./slave", "slave",text , "-i", max_writes,"-l",fname, NULL)) == -1)
 		                                                               {
											perror("slave : fail to exec the process image\n");
                                		                                        create_log(" slave: fail to exec the process image");
											perror("process : move to terminating sequence\n");
											create_log("process : move to terminating sequence");

                                                		                        savelog(fname);
											clearlog();
											kill_shm();
											kill_sem();
											perror("process : process is terminated due to fail to exec its process image\n");
											create_log("process : process is terminated due to fail for exec its process image");

                                                                		        return 1;
 		                                                               }
                		                                }
                                		}
 		                        else
                		                {
							p->pid[k] = temp_pid;
							p->priority[k] = 1;
							p->flag[k] = NEW;
							p->wait_t[k] = 0;
							p->turnaround_t[k] = 0;
							p->last_burst[k] = 0;
							p->r_process--;

							stock--;
							sleep(1);
                		                }
				}

			//convert every 10000000 nano second to second
			if(o->nsec >= 1000000)
				{
					o->nsec -= 1000000;
					o->sec++;
					stock++;
				}

			//overhead;
			o->nsec += rand()%1001;
			//queue up
			int k,l;
			for (k = 0; k<3;k++)
				{
					for (l = 1; l<MAXP;l++)
						{
							if (p->flag[l] == READY)
								{
									fprintf(stderr,"found ready process : process %d, priority = %d\n",l,p->priority[l]);
									if(p->priority[l] == k)
										{
											snprintf(str,sizeof(str),"oss : enqueued process %d at osc %d sec : %d nano sec\n",l,o->sec,o->nsec);
											fflush(stdout);
											create_log(str);
											memset(str,0,sizeof(str));
											savelog(fname);
											clearlog();

											put(l);
										}
								}
						}
				}

			//execute schedule
			do
				{
					o->nsec++;
					//load next process
					current_process = get();
	
					//queue is empty
					if (current_process == -1)
						{
							break;
						}
					else
						{
							fprintf(stderr,"current_process : %d\n",current_process);
							snprintf(str,sizeof(str),"oss : dequeued process %d at osc %d sec : %d nano sec\n",i,o->sec,o->nsec);
							fflush(stdout);
							create_log(str);
							memset(str,0,sizeof(str));
							savelog(fname);
							clearlog();

						}
					//re-check the process is ready or not
					if (p->flag[current_process] == READY)
						{
							//scheduling overhead
							int overhead = rand()%1001;
							o->nsec += overhead;
							fprintf(stderr,"oss : overhead is %d nano sec\n", overhead);
							snprintf(str,sizeof(str),"oss : overhead is %d nano second, now current osc is %d sec : %d nano sec\n",overhead,o->sec,o->nsec);
							fflush(stdout);
							create_log(str);
							memset(str,0,sizeof(str));
							savelog(fname);
							clearlog();

							if(o->nsec >= 1000000)
								{
									o->nsec -= 1000000;
									o->sec ++;
									stock++;
								}

							//change the flag
							switch(p->priority[current_process])
								{
									//priority 0
									//quantum will be 50
									//with RR
									case 0:
										p->quantum = 200;
										p->flag[current_process] = RUNNING;
										//int tmp1;
									//	int l_burst = 0;
										tmp_timer=0;
										while(1)
											{
												//semlock();
												o->nsec++;
												tmp_timer++;

												//case : process used the entire given quantum
												if(p->flag[current_process] == READY)
													{
														fprintf(stderr,"oss : process %d \n",current_process);
														fprintf(stderr,"==============================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"remaining job : %d\n",p->remain_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->remain_t[current_process]/1000000,p->remain_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();
														//semunlock();
														break;
													}
												//case : process is terminated
												else if(p->flag[current_process] == TERMINATE)
													{
														fprintf(stderr,"oss : process %d is done its job\n",current_process);
														fprintf(stderr,"============================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"turnaround time : %d\n\n",p->turnaround_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n turnaround time : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->turnaround_t[current_process]/1000000,p->turnaround_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();
														//semunlock();
														break;
													}
												//case : process could not spend all the quantum, 
												else if(tmp_timer > 200)
													{
														if(p->flag[current_process] == RUNNING)
															p->flag[current_process] = BLOCK;
														snprintf(str,sizeof(str),"oss : changed process %d's status (RUNNING->BLOCK) at osc %d sec : %d nano sec\n",current_process,o->sec,o->nsec);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();

														p->priority[current_process] = 1;
														fprintf(stderr,"oss : process %d is blocked by oss\n",current_process);
														fprintf(stderr,"===========================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"remaining job : %d\n",p->remain_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->remain_t[current_process]/1000000,p->remain_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();
														//semunlock();
														break;
													}
												else
													{
														if(o->nsec >= 1000000)
															{
																o->nsec -= 1000000;
																o->sec ++;
																stock++;
															}
														//fprintf(stderr,"o->sec : %d : o->nsec : %d\n",o->sec,o->nsec);
														//semunlock();
													}
											}
										break;
									//priority 1, FCFS
									case 1:
										fprintf(stderr,"priority of loaded process is %d",p->priority[current_process]);
										p->quantum = 500;
										p->flag[current_process] = RUNNING;
										tmp_timer = 0;
										while(1)
											{
												//semlock();
												if(o->nsec >= 1000000)
													{
														o->nsec -= 1000000;
														o->sec ++;
														stock++;
													}
												o->nsec++;

												if(p->flag[current_process] == READY)
													{
														if(p->remain_t[current_process]<250)
															p->priority[current_process] = 0;
														else if(p->remain_t[current_process] >= 500)
															p->priority[current_process] = 2;
														fprintf(stderr,"oss : process %d \n",current_process);
														fprintf(stderr,"==============================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"remaining job : %d\n",p->remain_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->remain_t[current_process]/1000000,p->remain_t[current_process]%1000000);
	
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();

														//semunlock();
														break;
													}
												else if (p->flag[current_process] == TERMINATE)
													{
														fprintf(stderr,"oss : process %d \n",current_process);
														fprintf(stderr,"==============================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"turnaround time : %d\n\n",p->turnaround_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n turnaround time : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->turnaround_t[current_process]/1000000,p->turnaround_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();
														//semunlock();
														break;

													}
												else if(tmp_timer > p->quantum)
													{
														if(p->flag[current_process] == RUNNING)
															p->flag[current_process] = BLOCK;
														snprintf(str,sizeof(str),"oss : changed process %d's status (RUNNING->BLOCK) at osc %d sec : %d nano sec\n",current_process,o->sec,o->nsec);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();

														p->priority[current_process] = 1;
														fprintf(stderr,"oss : process %d is blocked by oss\n",current_process);
														fprintf(stderr,"===========================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"remaining job : %d\n",p->remain_t[current_process]);
															snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->remain_t[current_process]/1000000,p->remain_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();
														//semunlock();
														break;
													}

												else
													{
														//fprintf(stderr,"o->sec : %d : o->nsec : %d\n",o->sec,o->nsec);
														//semunlock();
														continue;
													}
											}
										break;
									case 2:
										p->quantum = 1000;
										p->flag[current_process] = RUNNING;
										tmp_timer = 0;
										while(1)
											{
											//	semlock();
												o->nsec++;
												if(o->nsec >= 1000000)
													{			
														o->nsec -= 1000000;
														o->sec ++;
														stock++;
													}
												if(p->flag[current_process] == READY)
													{
														p->priority[current_process] = 1;
														fprintf(stderr,"oss : process %d \n",current_process);
														fprintf(stderr,"==============================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"remaining job : %d\n",p->remain_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->remain_t[current_process]/1000000,p->remain_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();

												//		semunlock();
														break;

													}
												else if(p->flag[current_process] == TERMINATE)
													{
														fprintf(stderr,"oss : process %d \n",current_process);
														fprintf(stderr,"==============================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"turnaround time : %d\n\n",p->turnaround_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n turnaround time : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->turnaround_t[current_process]/1000000,p->turnaround_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();
													//	semunlock();
														break;
													}
												else if(tmp_timer > p->quantum)
													{													
														if(p->flag[current_process] == RUNNING)
															p->flag[current_process] = BLOCK;
														snprintf(str,sizeof(str),"oss : changed process %d's status (RUNNING->BLOCK) at osc %d sec : %d nano sec\n",current_process,o->sec,o->nsec);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();

														p->priority[current_process] = 1;
														fprintf(stderr,"oss : process %d is blocked by oss\n",current_process);
														fprintf(stderr,"===========================\n");
														fprintf(stderr,"total waiting time : %d\n",p->wait_t[current_process]);
														fprintf(stderr,"last burst time : %d\n",p->last_burst[current_process]);
														fprintf(stderr,"remaining job : %d\n",p->remain_t[current_process]);
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/1000000,p->wait_t[current_process]%1000000, p->last_burst[current_process]/1000000,p->last_burst[current_process]%1000000, p->remain_t[current_process]/1000000,p->remain_t[current_process]%1000000);
														fflush(stdout);
														create_log(str);
														memset(str,0,sizeof(str));
														savelog(fname);
														clearlog();
														//semunlock();
														break;
													}
												else
													{
														//fprintf(stderr,"o->sec : %d : o->nsec : %d\n",o->sec,o->nsec);
														//semunlock();
													}
											}
										break;
								}
						}
				} while(current_process != -1);
			if(p->term_proc >= MAXP -1)
				break;
		}while((timer>o->sec)||(timer==o->sec));

	fprintf(stderr,"oss : exceed the time limit\n");
	fprintf(stderr,"oss : move to terminating sequence\n");
	create_log("oss : exceed the time limit");
	create_log("oss : move to terminating sequence");
	savelog(fname);
	clearlog();
	//do termination
	for (k = 1; k <= pcb_index;k++)
		{
			kill(p->pid[k], SIGKILL);
		}
	kill_shm();
	kill_sem();
	create_log("oss : terminate program");
	savelog(fname);
	return 0;
}

//signal handler
void 
sig_handler(int signo)
{
	fprintf(stderr, "oss : receive a signal to terminate");
	create_log("oss : receive a signal to terminate");
	savelog(fname);
	clearlog();
	kill_shm();
	kill_sem();
	sleep(1);
	exit (1);
}

//function for killing a shared memory
void 
kill_shm()
{
	if((shmctl(shmid, IPC_RMID, 0)) == -1)
		{
			perror("oss : fail to kill the shared memory\n");
			create_log("oss : fail to kill the shared memory");
			savelog(fname);
			clearlog();
		}
	else
		{
			fprintf(stderr,"oss : success to kill the shared memory\n");
			create_log("oss : success to kill the shared memory");
			savelog(fname);
			clearlog();
		}
	if((shmctl(turn_id, IPC_RMID, 0)) == -1)
		{
			perror("oss : fail to kill the second shared memory\n");
			create_log("oss : fail to kill the second shared memory");
			savelog(fname);
			clearlog();
		}
	else
		{
			fprintf(stderr,"oss : success to kill the second shared memory\n");
			create_log("oss : success to kill the second shared memory");
			savelog(fname);
			clearlog();
		}
}

void
kill_sem()
{
	if((semctl(semid, 0, IPC_RMID)) == -1)
		{
			perror("oss : fail to kill semaphore\n");
			create_log("oss : fail to kill semaphore");
			savelog(fname);
			clearlog();
		}
	else
		{
			perror("oss : success to kill the semaphore\n");
			create_log("oss : success to kill the semaphore");
			savelog(fname);
			clearlog();
		}
}

void
semlock()
{
	struct sembuf semo;
	semo.sem_num = 0;
	semo.sem_op = 1;
	semo.sem_flg = 0;
	if((semop(semid, &semo,1)) == -1)
		{
			perror("oss : fail to lock semaphore\n");
			create_log("oss : fail to lock semaphore");
			savelog(fname);
			clearlog();
			exit(1);
		}
}

void
semunlock()
{
	struct sembuf semo;
	semo.sem_num = 0;
	semo.sem_op = -1;
	semo.sem_flg = 0;
	if ((semop(semid,&semo, 1)) == -1)
		{
			perror("oss : fail to operate the semaphore\n");
			create_log("oss : fail to operate the semaphore");
			savelog(fname);
			clearlog();
			exit(1);
		}
}

void 
init_queue()
{
	p->front = -1;
	p->rear = -1;
}

void 
clear_queue()
{
	p->front = p->rear =-1;
}

int
put(int k)
{
	if(isFull()) 
		return 0;
	p->rear++;
	p->queue[p->rear % MAXP] = k;
	fprintf(stderr,"process %d is enqueued \n",k);
	return 1;
}

int
get()
{
	int i;
	if(isEmpty())
		return -1;
	else
		{
			p->front++;
			i = p->queue[p->front % MAXP];
			fprintf(stderr,"process %d is dequeued\n",i);
			return i;
		}
}

int
 isEmpty()
{
	return (p->front == p->rear);
}

int
isFull()
{
	return ((p->front - MAXP) == p->front);
}
@


1.63
log
@cant burst
@
text
@d534 2
a535 1

d539 1
a539 1
												semlock();
d542 1
d557 1
a557 1
														semunlock();
d574 1
a574 1
														semunlock();
d601 1
a601 1
														semunlock();
d613 1
a613 1
														semunlock();
d622 1
a622 1
										tmp_timer;
d625 1
a625 1
												semlock();
d633 1
d653 1
a653 1
														semunlock();
d669 1
a669 1
														semunlock();
d696 1
a696 1
														semunlock();
d703 1
a703 1
														semunlock();
d714 1
a714 1
												semlock();
d737 1
a737 1
														semunlock();
d754 1
a754 1
														semunlock();
d780 1
a780 1
														semunlock();
d786 1
a786 1
														semunlock();
@


1.62
log
@*** empty log message ***
@
text
@d448 1
a448 1
			if(o->nsec >= 100000000)
d450 1
a450 1
					o->nsec -= 100000000;
d518 1
a518 1
							if(o->nsec >= 100000000)
d520 1
a520 1
									o->nsec -= 100000000;
d532 1
a532 1
										p->quantum = 50;
d538 1
d549 1
a549 1
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000, p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000, p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
d555 1
a555 1

d566 1
a566 1
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n turnaround time : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000, p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000, p->turnaround_t[current_process]/100000000,p->turnaround_t[current_process]%100000000);
d572 1
a572 1

d576 1
a576 1
												else if(tmp_timer > 50)
d593 2
a594 2
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000, p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000, p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
															fflush(stdout);
d599 2
d604 1
a604 1
														if(o->nsec >= 100000000)
d606 1
a606 1
																o->nsec -= 100000000;
d610 2
d618 1
a618 1
										p->quantum = 250;
d620 1
a620 1
										
d623 2
a624 1
												if(o->nsec >= 100000000)
d626 1
a626 1
														o->nsec -= 100000000;
d642 1
a642 1
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000, p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000, p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
d650 1
a650 1

d660 1
a660 1
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n turnaround time : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000, p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000, p->turnaround_t[current_process]/100000000,p->turnaround_t[current_process]%100000000);
d666 2
d669 25
d695 1
a696 1
													}
d699 2
d706 1
a706 1
										p->quantum = 500;
d708 1
a708 1
										
d711 1
d713 1
a713 1
												if(o->nsec >= 100000000)
d715 1
a715 1
														o->nsec -= 100000000;
d727 1
a727 1
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n remaining job : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000, p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000, p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
d734 1
a734 1

d745 14
a758 1
														snprintf(str,sizeof(str),"oss : process %d \n ==============================\n total waiting time : %d sec %d nano sec\n last burst time : %d sec %d nano sec\n turnaround time : %d sec %d nano sec\n", current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000, p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000, p->turnaround_t[current_process]/100000000,p->turnaround_t[current_process]%100000000);
d765 13
d779 5
@


1.61
log
@put log for every msg
@
text
@d548 1
a548 8
														snprintf(str,sizeof(str),"oss : process %d \n
																	==============================\n
																	total waiting time : %d sec %d nano sec\n
																	last burst time : %d sec %d nano sec\n
																	remaining job : %d sec %d nano sec\n",
																	current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000,
																	p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000,
																	p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
d565 1
a565 8
														snprintf(str,sizeof(str),"oss : process %d \n
															==============================\n
															total waiting time : %d sec %d nano sec\n
															last burst time : %d sec %d nano sec\n
															turnaround time : %d sec %d nano sec\n",
															current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000,
															p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000,
															p->turnaround_t[current_process]/100000000,p->turnaround_t[current_process]%100000000);
d592 1
a592 8
														snprintf(str,sizeof(str),"oss : process %d \n
															==============================\n
															total waiting time : %d sec %d nano sec\n
															last burst time : %d sec %d nano sec\n
															remaining job : %d sec %d nano sec\n",
															current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000,
															p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000,
															p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
d636 1
a636 8
														snprintf(str,sizeof(str),"oss : process %d \n
															==============================\n
															total waiting time : %d sec %d nano sec\n
															last burst time : %d sec %d nano sec\n
															remaining job : %d sec %d nano sec\n",
															current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000,
															p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000,
															p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
d654 1
a654 8
														snprintf(str,sizeof(str),"oss : process %d \n
															==============================\n
															total waiting time : %d sec %d nano sec\n
															last burst time : %d sec %d nano sec\n
															turnaround time : %d sec %d nano sec\n",
															current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000,
															p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000,
															p->turnaround_t[current_process]/100000000,p->turnaround_t[current_process]%100000000);
d691 1
a691 8
														snprintf(str,sizeof(str),"oss : process %d \n
															==============================\n
															total waiting time : %d sec %d nano sec\n
															last burst time : %d sec %d nano sec\n
															remaining job : %d sec %d nano sec\n",
															current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000,
															p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000,
															p->remain_t[current_process]/100000000,p->remain_t[current_process]%100000000);
d709 1
a709 8
														snprintf(str,sizeof(str),"oss : process %d \n
															==============================\n
															total waiting time : %d sec %d nano sec\n
															last burst time : %d sec %d nano sec\n
															turnaround time : %d sec %d nano sec\n",
															current_process,p->wait_t[current_process]/100000000,p->wait_t[current_process]%100000000,
															p->last_burst[current_process]/100000000,p->last_burst[current_process]%100000000,
															p->turnaround_t[current_process]/100000000,p->turnaround_t[current_process]%100000000);
@


1.60
log
@*** empty log message ***
@
text
@d468 7
d494 8
a501 1
						fprintf(stderr,"current_process : %d\n",current_process);
d503 1
a506 1
							fprintf(stderr,"loading\n");
d511 7
d528 3
d540 1
a542 2
														if (p->rflag == 0)
															sleep(1);
d548 14
d564 1
a566 2
														if (p->rflag == 0)
															sleep(1);
d572 14
d588 1
d591 1
a591 1
														if(p->flag[current_process] != TERMINATE)
d593 7
d606 13
a618 1
														break;
d620 1
a620 1
												if(o->nsec >= 100000000)
d622 6
a627 3
														o->nsec -= 100000000;
														o->sec ++;
														stock++;
d631 1
d657 15
d682 14
d700 3
a702 1
													continue;
d726 14
d751 14
a769 1
							fprintf(stderr,"hi!");
a770 2
				else
					continue;
d772 1
a772 1
			if((p->r_process <= 0)&&(p->term_proc == MAXP -1))
@


1.59
log
@fixed errors
and now working for fixing another errors
@
text
@d253 1
d642 2
@


1.58
log
@need to fix queue
@
text
@d33 1
a33 1
void put(int);
d35 2
d358 1
d433 6
a438 3
                                        		//parent's job, record to pcb
							p->pid[pcb_index] = temp_pid;
							p->flag[pcb_index] = true;
d440 1
d442 1
a455 1
			
d464 1
d472 1
d476 1
d482 5
a486 1
						break;
d491 1
d493 3
a495 2
							o->nsec += rand()%1001;

a506 1
										semlock();
a508 1
										semunlock();
d549 6
d558 1
a558 1
										semlock();
a560 1
										semunlock();
d564 6
d595 2
a599 1
										semlock();
a601 1
										semunlock();
d606 6
d636 1
d638 2
d765 2
a766 2
	p->front = 0;
	p->rear = 0;
d772 1
a772 1
	p->front = p->rear;
d775 2
a776 2
void
 put(int k)
d778 6
a783 9
	if((p->rear+1) % MAXP == p->front)
		{
			perror("Queue overflow\n");
			exit(1);
		}

	p->queue[p->rear] = k;
	p->rear = ++p->rear % MAXP;
	
d790 3
a792 1
	if(p->front == p->rear)
d794 4
a797 2
			perror("Queue underflow\n");
			exit(1);
d799 12
a810 3
	i = p->queue[p->front];
	p->front = ++p->front % MAXP;
	return i;
@


1.57
log
@*** empty log message ***
@
text
@d63 1
a63 1

d250 2
d348 5
a352 1
					p->flag[k] = true;
d359 1
a359 1
			if(p->num_proc < process_num)
d434 1
a437 22
			//rflag = 1 means there is a new message to read
			if (o->rflag == 1)
				{
					
					//in cs
					semlock();
					struct timespec tpe;
					clock_gettime(CLOCK_REALTIME, &tpe);
					fprintf(stderr,"Master : at my time %d second, %d nano second\n%s ",tpe.tv_sec-tps.tv_sec,tpe.tv_nsec-tps.tv_nsec,o->st);
					snprintf(str,sizeof(str),"oss : at my time %d second, %d nano second\n %s\n",tpe.tv_sec-tps.tv_sec,tpe.tv_nsec-tps.tv_nsec,o->st);
					create_log(str);
					savelog(fname);
					clearlog();
					memset(str,0,sizeof(str));

					o->rflag = 0;
					semunlock();
				}
			//fprintf(stderr, "sec = %d, nsec = %d\n",o->sec,o->nsec);
			//increment 1~10 nanosec
			o->nsec += rand()%5+1;

d443 1
a445 2
			//cs
			semlock();
d484 1
d503 7
a509 2
														semlock();
														semunlock();
d514 7
a520 2
														semlock();
														semunlock();
a524 1
														semlock();
d528 5
a532 1
														semunlock();
a547 1
														semlock();
d552 6
a557 1
														semunlock();
d562 5
a566 2
														semlock();
														semunlock();
a582 1
														semlock();
d584 6
a589 1
														semunlock();
d595 5
a599 2
														semlock();
														semunlock();
a606 1
			semunlock();
@


1.56
log
@put queue function into the shm struct
@
text
@d34 1
a34 1
void get(void);
d53 3
d462 1
d464 131
d744 1
a744 1
void
d755 1
a755 1
	
@


1.55
log
@*** empty log message ***
@
text
@d21 1
d30 6
d64 1
a64 1
	pcb *p;
d246 1
a246 1
	p->r_process = 100;
d456 5
d580 41
@


1.54
log
@*** empty log message ***
@
text
@d54 1
a54 1
	struct timespec tps, tpe;
d424 1
d427 1
d430 1
a430 1
					snprintf(str,sizeof(str),"oss : at my time %d second, %d nano second\n %s\n",o->st);
@


1.53
log
@*** empty log message ***
@
text
@d11 1
d54 2
d246 3
d426 3
a428 3
					
					fprintf(stderr,"%s",o->st);
					snprintf(str,sizeof(str),"oss : %s\n",o->st);
@


1.52
log
@improve message, and comments
@
text
@d319 1
a319 1
									reate_log("process : process is terminated due to fail for exec its process image");
@


1.51
log
@fix log part,
@
text
@a112 12
					//-i switch for max_write
					case 'i':
						iflag = 1;
						value = strtol(optarg,&endptr,10);
						if(*endptr != '\0')
							{
								printf("oss you must type digits after -i, not %s",stderr);
								return 1;
							}
						max_writes = (char *)malloc(strlen(optarg)+1);
						strcpy(max_writes,optarg);
						break;
a144 1
			printf("-i [value]\n change maximum number of writing for slave process to [value]\n");
d262 2
d266 2
d270 4
d286 2
d290 1
d293 4
d310 2
d314 1
d317 5
d351 2
d357 2
d372 3
d379 2
d392 3
d399 3
d408 1
a408 1
                                        
d433 1
a433 1
			o->nsec += rand()%10+1;
d442 7
a448 1
	fprintf(stderr,"osc : exceed the time limit\t");
@


1.50
log
@worked for fork part for additional spawning
@
text
@d51 1
d92 1
a92 1
								printf("master : you must type digits after -s, not %s",stderr);
d98 1
a98 1
								fprintf(stderr,"master : cannot spawn more than %s processes\n",MAXP);
d107 1
a107 1
								perror("master : you must type file name after -l switch.");
d119 1
a119 1
								printf("master you must type digits after -i, not %s",stderr);
d131 1
a131 1
								printf("master : you must type digits after -t, not %s",stderr);
d158 1
a158 1
			printf("-t [value]\n change the termination timer for master process to [value] second\n");
d165 1
a165 1
        if ((shmid = shmget((key_t)12348888, sizeof(int), 0600|IPC_CREAT)) == -1)
d167 2
a168 2
                        perror("master : fail to create a shared memory\n");
                        create_log("master : fail to create a shared memory\n");
d174 1
a174 1
                        create_log("master : created a shared memory");
d179 1
a179 1
        if ((turn_id = shmget((key_t)88881234, sizeof(int)*20, 0600|IPC_CREAT)) == -1)
d181 2
a182 2
                        perror("master : fail to create a shared memory for the peterson algorithm\n");
                        create_log("master : fail to create a shared memory for the peterson algorithm\n");
d188 1
a188 1
                        create_log("master : created a second shared memory");
d196 2
a197 2
                        perror("master : fail to attatch the shared memory\n");
                        create_log("master : fail to attatch the shared memory");
d203 1
a203 1
                        create_log("master : success to attatch the shared memory");
d210 2
a211 2
                        perror("master : fail to attatch the second shared memory\n");
                        create_log("master : fail to attatch the second shared memory");
d217 1
a217 1
                        create_log("master : success to attatch the second shared memory");
d246 1
a246 1
	//assign master process to 0th slot
d263 1
a263 1
			create_log("master : forking a child process");
d273 2
a274 2
					perror("master : fail to fork a child process\n");
					create_log("master : fail to fork a child process");
d276 3
d292 3
d309 3
d333 1
a333 1
					create_log("master : forking a child process");
d339 2
a340 2
                		                        perror("master : fail to fork a child process\n");
 		                                        create_log("master : fail to fork a child process");
d342 3
d359 3
d374 3
d390 1
d393 1
d395 1
d397 6
d407 1
d409 2
d417 1
a417 1

d419 1
a419 1
	for (k = 1; k < process_num+1;k++)
d425 1
a425 1
	create_log("master : terminate program");
d434 2
a435 2
	fprintf(stderr, "master : receive a signal to terminate");
	create_log("master : receive a signal to terminate");
d450 2
a451 2
			perror("master : fail to kill the shared memory\n");
			create_log("master : fail to kill the shared memory");
d457 2
a458 2
			fprintf(stderr,"master : success to kill the shared memory\n");
			create_log("master : success to kill the shared memory");
d464 2
a465 2
			perror("master : fail to kill the second shared memory\n");
			create_log("master : fail to kill the second shared memory");
d471 2
a472 2
			fprintf(stderr,"master : success to kill the second shared memory\n");
			create_log("master : success to kill the second shared memory");
@


1.49
log
@fixing convergence for nano second part (had one more 0)
@
text
@d50 1
d247 2
a248 1
	p->num_proc = process_num+1;
d258 3
d265 2
d268 2
d308 1
d310 2
d317 54
@


1.48
log
@changed shared memory. now the master process will increment clock
@
text
@d305 7
d313 2
a314 2
			o->nsec ++;
			if(o->nsec >= 10000)
d316 1
a316 1
					o->nsec -= 10000;
@


1.47
log
@implementing semaphore
@
text
@a51 1
	int *shmptr;
d53 1
d192 1
a192 1
        if ((shmptr = shmat (shmid, NULL, 0)) == -1)
d249 3
a251 4
	//initialize shmptr to 0
	int *cal_num;
	cal_num = (int *) shmptr;
	*cal_num = 0;
d302 11
a313 2
	//sleep
	sleep(timer);
d320 1
d335 1
a382 1
			exit(1);
@


1.46
log
@fixing log
@
text
@d10 1
d18 1
d24 3
d220 15
a234 1

d361 54
@


1.45
log
@*** empty log message ***
@
text
@a51 51
	//create a shared memory
	if ((shmid = shmget((key_t)12348888, sizeof(int), 0600|IPC_CREAT)) == -1)
		{
			perror("master : fail to create a shared memory\n");
			create_log("master : fail to create a shared memory\n");
			savelog(fname);
			return 1;
		}
	else
		{
			create_log("master : created a shared memory");
		}

	if ((turn_id = shmget((key_t)88881234, sizeof(int)*20, 0600|IPC_CREAT)) == -1)
		{
			perror("master : fail to create a shared memory for the peterson algorithm\n");
			create_log("master : fail to create a shared memory for the peterson algorithm\n");
			savelog(fname);
			return 1;
		}
	else
		{
			create_log("master : created a second shared memory");
		}
	
	//attatching shared memory
	//first shm for data
	if ((shmptr = shmat (shmid, NULL, 0)) == -1)
		{
			perror("master : fail to attatch the shared memory\n");
			create_log("master : fail to attatch the shared memory");
			savelog(fname);
			return 1;
		}
	else
		{
			create_log("master : success to attatch the shared memory");
		}
	//second for the algorithm
	if ((p = (pcb *)shmat(turn_id,NULL,0)) == -1)
		{
			perror("master : fail to attatch the second shared memory\n");
			create_log("master : fail to attatch the second shared memory");
			savelog(fname);
			return 1;
		}
	else
		{
			create_log("master : success to attatch the second shared memory");
		}

d154 63
a216 1
	
d239 3
d293 2
d304 2
a306 1
	savelog(fname);
d319 2
d326 2
d333 2
d340 2
@


1.44
log
@peeeeeeeeeeeeteeeeeeeeeeeeeeerssoooooooooooooooooooooooon!!!!
@
text
@a209 2
			p->choosing[k] = 0;
			p->number[k] = 0;
@


1.43
log
@*** empty log message ***
@
text
@d213 1
d218 1
@


1.42
log
@*** empty log message ***
@
text
@d140 5
@


1.41
log
@fixed shared memory
@
text
@d235 1
@


1.40
log
@*** empty log message ***
@
text
@d215 3
a217 1
	shmptr = 0;
@


1.39
log
@*** empty log message ***
@
text
@a244 1
							fprintf(stderr,text);
@


1.38
log
@convert all printf to fprintf w/ stderr
@
text
@d220 1
d245 1
a245 1
							printf(text);
@


1.37
log
@*** empty log message ***
@
text
@d27 1
a28 1
	char *e;			//for strtol
d53 1
a53 1
	if ((shmid = shmget((key_t)1234, sizeof(int), 0600|IPC_CREAT)) == -1)
d65 1
a65 1
	if ((turn_id = shmget((key_t)8888, sizeof(int)*20, 0600|IPC_CREAT)) == -1)
d243 2
a244 1
							sprintf(text, "%d", k);
d278 1
a278 1
	printf("master : receive a signal to terminate");
d297 1
a297 1
			printf("master : success to kill the shared memory\n");
d307 1
a307 1
			printf("master : success to kill the second shared memory\n");
@


1.36
log
@*** empty log message ***
@
text
@d233 1
a233 1
							if((execl(".slave", "slave",text, "-i", max_writes, "-l", fname, NULL)) == -1)
@


1.35
log
@fixing
@
text
@d233 1
a233 1
							if((execl(".slave", "slave", "-i", max_writes, "-l", "fname", NULL)) == -1)
d246 1
a246 1
							if((execl("./slave", "slave",text , "-i", max_writes, NULL)) == -1)
@


1.34
log
@fixing err
@
text
@d44 1
d243 1
d246 1
a246 1
							if((execl("./slave", "slave", "-i", max_writes, NULL)) == -1)
@


1.33
log
@*** empty log message ***
@
text
@d17 1
d27 1
a27 1
	char *fname = "test.out";	//for -l switch, default is logfile.txt
@


1.32
log
@*** empty log message ***
@
text
@d8 2
d25 1
a25 1
	int c, hflag, sflag, lflag, iflag tflag;
@


1.31
log
@*** empty log message ***
@
text
@d229 1
a229 1
							if((execl(".slave", "slave", max_writes, "-l", "fname", NULL)) == -1)
d241 1
a241 1
							if((execl("./slave", "slave", max_writes, NULL)) == -1)
@


1.30
log
@*** empty log message ***
@
text
@d226 1
a226 3
					//place for child
					//exec
					if((execl("./slave", "slave", max_writes, NULL)) == -1)
d228 21
a248 5
							//getting error 
							perror("slave : fail to exec the process image\n");
							create_log(" slave: fail to exec the process image");
							savelog(fname);
							return 1;
@


1.29
log
@*** empty log message ***
@
text
@d201 2
a202 2
			p->choosing[k] = -1;
			p->number[k] = -1;
d210 3
@


1.28
log
@*** empty log message ***
@
text
@d24 1
a24 1
	char *fname = "logfile.txt";	//for -l switch, default is logfile.txt
@


1.27
log
@*** empty log message ***
@
text
@d28 1
a28 1
	char *strbuff = "42";		//handling default value for -n
d39 1
a39 1
	long max_writes = 3;		//maximum number of writing
d157 2
a158 2
						strbuff = (char *)malloc(strlen(optarg)+1);
						strcpy(strbuff,optarg);
d225 1
a225 1
					if((execl("./slave", "slave", strbuff, NULL)) == -1)
@


1.26
log
@working
combine 2nd 3rd shm 
add bakery algo
add pcb.h
fix fork
@
text
@d23 1
a23 1
	int c, hflag, nflag, lflag;
d37 4
a40 2
	int i;
	int process_num = 19;		//number of process
d43 1
a43 1
	char *shmptr;
d49 1
a49 1
	if ((shmid = shmget((key_t)1234, sizeof(char)*1024, 0600|IPC_CREAT)) == -1)
d103 1
a103 1
	nflag = 0;
d105 2
d117 1
a117 1
		while(( c = getopt_long(argc,argv, ":hn:l:", options,&option_index)) != -1)
d125 2
a126 3
					case 'n':
						nflag = 1;
						printf("%s\n",optarg);
d132 1
a132 1
								printf("test : you must type digits after -n, not %s",stderr);
d135 1
a135 2
						strbuff = (char *)malloc(strlen(optarg)+1);
						strcpy(strbuff,optarg);
d142 1
a142 1
								perror("test : you must type file name after -l switch.");
d148 23
d190 1
a190 1
			printf("-n [value]\n to print [value] on the logfile\n");
d192 3
a194 22
		}
	else
		{
			create_log(strbuff);
			//if no switch
			//just test the loglib
			//next 3 lines will test addmsg func
			create_log("TEST : this is test msg");
			create_log("TEST : this is test msg for queue");
			create_log("TEST : this is test msg for clearfunc");
	
			savelog(fname);
	
			//next 2 lines will test getlog func
			char *strings = getlog();
			printf("%s", strings);


			//next 3 will test clearlog func
			clearlog();
			strings = getlog();
			printf("%s", strings);
d211 1
a211 1
	for(k = 1; k<MAXP; k++)
d225 1
a225 1
					if((execl("./slave", "slave")) == -1)
d240 4
a243 2
	//bakery
	while(1)
d245 1
a245 29
			p->choosing[i] = true;
			p->number[i] = 1 + max((((((((((((((((((p->number[0],p->number[1]),
			p->number[2]),
			p->number[3]),
			p->number[4]),
			p->number[5]),
			p->number[6]),
			p->number[7]),
			p->number[8]),
			p->number[9]),
			p->number[10]),
			p->number[11]),
			p->number[12]),
			p->number[13]),
			p->number[14]),
			p->number[15]),
			p->number[16]),
			p->number[17]),
			p->number[18]);
			p->choosing[i] = false;
			int j;
			for (j = 0; j<n; j++)
				{
					while(p->choosing[j]);
					while((p->number[j]) && (p->number[j],j)<(p->number[i],i));
				}
			//crit
			p->number[i] = 0;
			//remainder
d247 1
a247 1

@


1.25
log
@*** empty log message ***
@
text
@d33 1
a33 1
	int pid;			//for pid
d35 1
d37 1
a37 1
	int index;
d190 9
d200 3
a202 2
	//fork
	pid = fork();
d204 2
a205 8
	if (pid == -1)
		{
			perror("master : fail to fork a child process\n");
			create_log("master : fail to fork a child process");
			savelog(fname);
			return 1;
		}
	else if(pid == 0)
d207 2
a208 3
			//place for child
			//exec
			if((execl("./slave", "slave")) == -1)
d210 2
a211 3
					//getting error 
					perror("slave : fail to exec the process image\n");
					create_log(" slave: fail to exec the process image");
d215 17
d233 3
a235 1
	else
d237 22
a258 2
			//place for parent 
			while(1)
d260 2
a261 12
					pcb->choosing[i] = true;
					pcb->number[i] = 1 + max(number[0]...);
					pcb->choosing[i] = false;
					int j;
					for (j = 0; j<n; j++)
						{
							while(pcb->choosing[j]);
							while((pcb->number[j]) && (number[j],j)<(number[i],i));
						}
					//crit
					number[i] = 0;
					//remainder
d263 3
@


1.24
log
@adding flag, so now i have 3 shm
@
text
@d9 2
a14 1
int flags_id;
d37 1
d41 1
a41 2
	int *turn_ptr;
	int *flags_ptr;
a69 12
	if ((flags_id = shmget((key_t)4321, sizeof(int)*20, 0600|IPC_CREAT)) == -1)
		{
			perror("master : fail to create third shared memory\n");
			create_log("master : fail to create third shared memory)");
			savelog(fname);
			return 1;
		}
	else
		{
			create_log("master : created thid shared memory");
		}

d71 1
d83 2
a84 1
	if ((turn_ptr = shmat(turn_id,NULL,0)) == -1)
a95 12
	if((flags_ptr = shmat(flags_id,NULL,0)) == -1)
		{
			perror(" master : fail to attatch third shared memory\n");
			create_log("master : fail to attatch third shared memory");
			savelog(fname);
			return 1;
		}
	else
		{
			create_log("master : success to attatch third shared memory");
		}

d216 15
a270 10
		}
	if((shmctl(turn_id, IPC_RMID, 0)) == -1)
		{
			printf("master : success to kill third shared memory\n");
			create_log("master : success to kill shird shared memory");
		}
	else
		{
			printf("master : success to kill third shared memory\n");
			create_log("master : success to kill third shared memory");
@


1.23
log
@put another shm
@
text
@d13 1
d35 2
d40 1
d68 12
d105 12
d277 10
@


1.22
log
@working for shm
@
text
@d12 1
d36 1
d40 2
a41 1
	if ((shmid = shmget((key_t)1234, sizeof(int), 0700|IPC_CREAT)) == -1)
d53 13
d77 11
d150 1
d214 1
d220 1
d226 1
d233 1
a233 1
			create_log("master : fail to kill the shared memory\n");
d238 11
a248 1
			create_log("master : success to kill the shared memory\n");
@


1.21
log
@working shm
@
text
@d10 3
d15 1
d33 1
a33 1
	int shmid;
d186 2
a187 1
void sig_handler(int signo)
d194 15
@


1.20
log
@worked for fork/exec
@
text
@d29 3
d33 24
@


1.19
log
@working for p2
just adding & testing signal func
@
text
@d10 1
d26 2
a27 2
	int pid;
	int sig_num;
d29 1
a29 5
	signal(SIGINT, sig_handler);
	while(1)
	{

	}
d124 28
d157 3
a159 1
	printf("hi");
@


1.18
log
@adding missing comments
@
text
@d6 2
d10 2
d25 8
d128 7
@


1.17
log
@n is working now
@
text
@d15 2
a16 2
	int err_flag = 0;
	char *strbuff = "42";
d18 2
a19 2
	char *endptr;
	long value;
d41 1
d45 1
d49 2
d60 1
d71 1
d78 1
a78 1
	
d89 1
a89 1
			printf("-n \n");
@


1.16
log
@*** empty log message ***
@
text
@d18 3
d46 3
a48 6
						if(isdigit(optarg))
							{
								strbuff = (char*) malloc(strlen(optarg)+1);
								strcpy(strbuff, optarg);
							}
						else
d50 1
a50 1
								perror("test : you must type digits after -n");
d53 2
@


1.15
log
@*** empty log message ***
@
text
@a11 1
	int n_digit = 42;		//for -n switch
d16 1
a16 1
	char *strbuff;
@


1.14
log
@working on -n
@
text
@d46 1
a46 1
								strbuff = (char*) malloc(optarg)+1);
@


1.13
log
@fixing some missing stuffs
-n is still working
@
text
@d12 1
a12 1
	int log_timer = 1;		//for -n switch
d17 1
d44 1
a44 2
						log_timer = atoi(optarg);
						if(log_timer < 1)
d46 6
a51 1
								perror("test : log timer must grater than 0");
d87 1
@


1.12
log
@-l is finished
-h is finished
-n is incomplete
@
text
@d35 1
a35 1
		while(( c = getopt_long(argc,argv, ":h:n:l:", options,&option_index)) != -1)
d43 6
a48 1
						printf("%s opt is b\n",optarg);
@


1.11
log
@finish -l switch
@
text
@a39 1
						printf("%s opt\n",optarg);
d47 5
d71 3
@


1.10
log
@*** empty log message ***
@
text
@d48 2
a49 1
						printf("optarg is %sn .\n",optarg);
@


1.9
log
@added error flag
@
text
@d18 3
d28 2
a29 1
		{"help", 0, 0, 'h'}
d35 1
a35 1
		while(( c = getopt_long(argc,argv, ":h:n:l", options,&option_index)) != -1)
d40 1
d44 1
d48 1
@


1.8
log
@*** empty log message ***
@
text
@d16 1
d44 2
a45 1
						printf("Unknown option : %s is found\n", optopt);
d50 4
@


1.7
log
@replace getopt to getopt long
@
text
@d11 1
a11 1
	int c, hflag, nflag, lfag;
d42 2
a43 1
					default:
@


1.6
log
@rcs for "NEW" edited main.c
main is required to change for accepting new switches
@
text
@d5 1
d11 5
a15 1
	int c, hflag;
d17 12
a28 5
	iflag =0;
	//getopt
	//will use just iflag
	//no error checking
	//just simple and basic one 
d30 1
a30 1
		while(( c = getopt(argc,argv, ":i")) != -1)
d33 8
a40 2
					case 'i':
						iflag = 1;
d49 1
a49 1
	if (iflag == 1)
d62 1
a62 1
			savelog("log.txt");
@


1.5
log
@fix getopt
@
text
@d10 1
a10 1
	int c, iflag;
@


1.4
log
@tried to follow GNU coding standard
@
text
@d4 1
d12 1
d18 1
a18 1
		while(( c = getopt(argc,argv, ":i:")) != -1)
@


1.3
log
@*** empty log message ***
@
text
@d6 2
a7 1
int main(int argc, char *argv[]){
d29 4
a32 3
	if (iflag == 1){
		printf("this program is designed for testing log library function\n");
	}
d34 7
a40 7
	{
		//if no switch
		//just test the loglib
		//next 3 lines will test addmsg func
		create_log("TEST : this is test msg");
		create_log("TEST : this is test msg for queue");
		create_log("TEST : this is test msg for clearfunc");
d42 1
a42 1
		savelog("log.txt");
d44 4
a47 3
		//next 2 lines will test getlog func
		char *strings = getlog();
		printf("%s", strings);
d49 5
a54 5
		//next 3 will test clearlog func
		clearlog();
		strings = getlog();
		printf("%s", strings);
	}
@


1.2
log
@fixing some errors
@
text
@d39 3
a41 1
		
d45 1
@


1.1
log
@Initial revision
@
text
@d1 1
d6 19
a24 1
int main(int argc, char **argv){
d26 23
@
